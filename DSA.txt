This file contains the Important Question on DSA
---------------------------------------------------------------------------------------------------------
1->Shortest Distance in a Binary Maze
------------------------------------------
MediumAccuracy: 58.22%Submissions: 57K+Points: 4
Be the comment of the day in POTD and win a GfG T-Shirt!
Solve right now

banner
Given a n * m matrix grid where each element can either be 0 or 1. You need to find the shortest distance between a given source cell to a destination cell. The path can only be created out of a cell if its value is 1. If the path is not possible between source cell and destination cell, then return -1.
Note : You can move into an adjacent cell if that adjacent cell is filled with element 1. Two cells are adjacent if they share a side. In other words, you can move in one of the four directions, Up, Down, Left and Right. The source and destination cell are based on the zero based indexing. The destination cell should be 1.

Example 1:

Input:
grid[][] = {{1, 1, 1, 1},
            {1, 1, 0, 1},
            {1, 1, 1, 1},
            {1, 1, 0, 0},
            {1, 0, 0, 1}}
source = {0, 1}
destination = {2, 2}
Output:
3
Explanation:
1 1 1 1
1 1 0 1
1 1 1 1
1 1 0 0
1 0 0 1
The highlighted part in the matrix denotes the 
shortest path from source to destination cell.
Example 2:

Input:
grid[][] = {{1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1},
            {1, 1, 1, 1, 0},
            {1, 0, 1, 0, 1}}
source = {0, 0}
destination = {3, 4}
Output:
-1
Explanation:
The path is not possible between source and 
destination, hence return -1.
Your Task:

You don't need to read or print anything. Your task is to complete the function shortestPath() which takes the a 2D integer array grid, source cell and destination cell as an input parameters and returns the shortest distance between source and destination cell.

Expected Time Complexity: O(n * m)
Expected Space Complexity: O(n * m)

Constraints:

1 ≤ n, m ≤ 500
grid[i][j] == 0 or grid[i][j] == 1
The source and destination cells are always inside the given matrix.
-----------
Solution
----------------------------------------------------------------------------------------
class Solution {

    int shortestPath(int[][] grid, int[] source, int[] destination) {

        // Your code here
        int[] delRow={-1,0,0,1};
        int[] delCol={0,-1,1,0};
        int[][] dist=new int[grid.length][grid[0].length];
        Queue<Pair> queue=new LinkedList<>();
        for(int i=0;i<grid.length;i++)
        {
            Arrays.fill(dist[i],Integer.MAX_VALUE);
        }
        dist[source[0]][source[1]]=0;
        queue.add(new Pair(source[0],source[1],0));
        while(!queue.isEmpty())
        {
            int row=queue.peek().row;
            int col=queue.peek().col;
            int count=queue.peek().count;
            if(row==destination[0] && col==destination[1])
            return count;
            queue.poll();
            for(int i=0;i<4;i++)
            {
                int currRow=row+delRow[i];
                int currCol=col+delCol[i];
                int currCount=count+1;
                if(currRow>=0 && currRow<grid.length && currCol>=0 &&
                    currCol<grid[0].length && grid[currRow][currCol]!=0
                    && dist[currRow][currCol]==Integer.MAX_VALUE
                ){
                    dist[currRow][currCol]=currCount;
                    queue.add(new Pair(currRow,currCol,currCount));
                }
            }
        }
        return -1;
    }
}

class Pair{
    int row,col,count;
    Pair(int row,int col,int count)
    {
        this.row=row;
        this.col=col;
        this.count=count;
    }
}
--------------------------------------------------------------------------------------------------
2>
Shortest Source to Destination Path
MediumAccuracy: 24.69%Submissions: 110K+Points: 4
Be the comment of the day in POTD and win a GfG T-Shirt!
Solve right now

banner
Given a 2D binary matrix A(0-based index) of dimensions NxM. Find the minimum number of steps required to reach from (0,0) to (X, Y).
Note: You can only move left, right, up and down, and only through cells that contain 1.

Example 1:

Input:
N=3, M=4
A=[[1,0,0,0], 
   [1,1,0,1],
   [0,1,1,1]]
X=2, Y=3 
Output:
5
Explanation:
The shortest path is as follows:
(0,0)->(1,0)->(1,1)->(2,1)->(2,2)->(2,3).
Example 2:

Input:
N=3, M=4
A=[[1,1,1,1],
   [0,0,0,1],
   [0,0,0,1]]
X=0, Y=3
Output:
3
Explanation:
The shortest path is as follows:
(0,0)->(0,1)->(0,2)->(0,3).
Your Task:
You don't need to read input or print anything. Your task is to complete the function shortestDistance() which takes the integer N, M, X, Y, and the 2D binary matrix A as input parameters and returns the minimum number of steps required to go from (0,0) to (X, Y).If it is impossible to go from (0,0) to (X, Y),then function returns -1. If value of the cell (0,0) is 0 (i.e  A[0][0]=0) then return -1.

Expected Time Complexity:O(N*M)
Expected Auxillary Space:O(N*M)

Constraints:
1 <= N,M <= 250
0 <= X < N
0 <= Y < M
0 <= A[i][j] <= 1
--------------------------------------------------------
Solution------------------------
class Solution {
    int shortestDistance(int N, int M, int A[][], int X, int Y) {
        // code here
        if(A[0][0]==0) return -1;
        int delRow[]={-1,0,0,1};
        int delCol[]={0,-1,1,0};
        int[][] arr=new int[A.length][A[0].length];
        for(int i=0;i<A.length;i++)
        {
            Arrays.fill(arr[i],-1);
        }
        Queue<Pair> queue=new LinkedList<>();
        queue.add(new Pair(0,0,0));
        while(!queue.isEmpty())
        {
            int row=queue.peek().row;
            int col=queue.peek().col;
            int count=queue.peek().count;
            if(row==X && col==Y){
                // System.out.println(X+" "+Y +" "+row+" "+col+"");
            return count;
            }
            queue.poll();
            for(int i=0;i<4;i++)
            {
                int currRow=row+delRow[i];
                int currCol=col+delCol[i];
                if(currRow>=0 && currRow<A.length && currCol>=0 && currCol<A[0].length
                    && A[currRow][currCol]!=0 && arr[currRow][currCol]==-1
                )
                {
                    arr[currRow][currCol]=1;
                    queue.add(new Pair(currRow,currCol,count+1));
                }
            }
        }
        return -1;
    }
};

class Pair{
    int row,col,count;
    Pair(int row,int col,int count)
    {
        this.row=row;
        this.col=col;
        this.count=count;
    }
}
---------------------------------------------------------------------------------------------------------------
3>
Shortest Path in Weighted undirected graph
MediumAccuracy: 50.0%Submissions: 39K+Points: 4
Be the comment of the day in POTD and win a GfG T-Shirt!
Solve right now

banner
You are given a weighted undirected graph having n vertices numbered from 1 to n and m edges describing there are edges between a to b with some weight, find the shortest path between the vertex 1 and the vertex n and if path does not exist then return a list consisting of only -1.

Note - 
1. If there exists a path, then return a list whose first element is the weight of the path.
2. If no path exists then return a list containing a single element -1.

Example:
Input:
n = 5, m= 6
edges = [[1,2,2], [2,5,5], [2,3,4], [1,4,1],[4,3,3],[3,5,1]]
Output:
5 1 4 3 5
Explaination:
Shortest path from 1 to n is by the path 1 4 3 5 whose weight is 5. 

Your Task:
You don't need to read input or print anything. Your task is to complete the function shortestPath() which takes n vertex and m edges and vector of edges having weight as inputs and returns the shortest path between vertex 1 to n.

Expected Time Complexity: O(m* log(n))
Expected Space Complexity: O(n)

Constraint:
2 <= n <= 105
0 <= m <= 105
0<= a, b <= n
1 <= w <= 105
------------------------------------------------
class Solution{
    public List<Integer> shortestPath(int n, int m, int edges[][]){
        //  Code Here.
        ArrayList<ArrayList<Pair>> adj=new  ArrayList<>();
        for(int i=0;i<n+1;i++)
        adj.add(new ArrayList<>());
        for (int i = 0; i < m; i++) {
            adj.get(edges[i][0]).add(new Pair(edges[i][1], edges[i][2]));
            adj.get(edges[i][1]).add(new Pair(edges[i][0], edges[i][2])); // Assuming undirected graph
        }
        int[] parent=new int[n+1];
        int dist[]=new int[n+1];
        Arrays.fill(dist,Integer.MAX_VALUE);
        for(int i=0;i<n+1;i++)
        parent[i]=i;
        dist[1]=0;
        ArrayList<Integer> path=new ArrayList<>();
        PriorityQueue<Pair> queue=new PriorityQueue<>((x1,x2)->x1.weight-x2.weight);
        queue.add(new Pair(1,0));
        while(!queue.isEmpty())
        {
            int node=queue.peek().node;
            int weight=queue.peek().weight;
            queue.poll();
            for(Pair pair:adj.get(node))
            {
                int currNode=pair.node;
                int currWeight=pair.weight;
                if(dist[currNode]>weight+currWeight)
                {
                    dist[currNode]=weight+currWeight;
                    queue.add(new Pair(currNode,dist[currNode]));
                    parent[currNode]=node;
                }
            }
        }
        // for(int i=0;i<n+1;i++)
        // {
        //     System.out.print(dist[i]+" -"+n);
        // }
        if(dist[n]==Integer.MAX_VALUE)
        {
            // System.out.println("NO");
            path.add(-1);
            return path;
        }
        int node=n;
        while(parent[node]!=node)
        {
            path.add(node);
            node=parent[node];
        }
        
        path.add(1);
        Collections.reverse(path);
        // System.out.println(dist[n-1]);
        path.add(0,dist[n]);
    // System.out.println(path);
        // path.add(parent[n]);
        return path;
        
    }
}
class Pair{
    int node,weight;
    Pair(int node,int weight)
    {
        this.node=node;
        this.weight=weight;
    }
}
------------------------------------------------------------------------------------------------------------------------------
4>
------------------------------
Distance from the Source (Bellman-Ford Algorithm)
MediumAccuracy: 48.11%Submissions: 100K+Points: 4
Be the comment of the day in POTD and win a GfG T-Shirt!
Solve right now

banner
Given a weighted and directed graph of V vertices and E edges, Find the shortest distance of all the vertex's from the source vertex S. If a vertices can't be reach from the S then mark the distance as 10^8. Note: If the Graph contains a negative cycle then return an array consisting of only -1.

Example 1:

Input:

E = [[0,1,9]]
S = 0
Output:
0 9
Explanation:
Shortest distance of all nodes from
source is printed.
Example 2:

Input:

E = [[0,1,5],[1,0,3],[1,2,-1],[2,0,1]]
S = 2
Output:
1 6 0
Explanation:
For nodes 2 to 0, we can follow the path-
2-0. This has a distance of 1.
For nodes 2 to 1, we cam follow the path-
2-0-1, which has a distance of 1+5 = 6,
--------------------------------------------------
class Solution {
    static int[] bellman_ford(int V, ArrayList<ArrayList<Integer>> edges, int S) {
        // Write your code here
        int[] dist=new int[V];
        Arrays.fill(dist,100000000);
        dist[S]=0;
        for(int i=0;i<V;i++)
        {
            for(int j=0;j<edges.size();j++)
            {
                int source=edges.get(j).get(0);
                int dest=edges.get(j).get(1);
                int cost=edges.get(j).get(2);
                if(dist[source]!=100000000 &&   dist[dest]>dist[source]+cost)
                {
                    dist[dest]=dist[source]+cost;
                }
            }
        }
        for(int j=0;j<edges.size();j++)
            {
                int source=edges.get(j).get(0);
                int dest=edges.get(j).get(1);
                int cost=edges.get(j).get(2);
                if(dist[source]!=100000000 &&  dist[dest]>dist[source]+cost)
                {
                    return new int[] {-1};
                }
            }
            return dist;
    }
}
---------------------------------------------------------------------------------------------------------------------------
5>
-----------------------------------
Minimum Spanning Tree
MediumAccuracy: 47.82%Submissions: 117K+Points: 4
Be the comment of the day in POTD and win a GfG T-Shirt!
Solve right now

banner
Given a weighted, undirected, and connected graph with V vertices and E edges, your task is to find the sum of the weights of the edges in the Minimum Spanning Tree (MST) of the graph. The graph is represented by an adjacency list, where each element adj[i] is a vector containing pairs of integers. Each pair represents an edge, with the first integer denoting the endpoint of the edge and the second integer denoting the weight of the edge.

Example 1:

Input:
3 3
0 1 5
1 2 3
0 2 1

Output:
4
Explanation:

The Spanning Tree resulting in a weight
of 4 is shown above.
Example 2:

Input:
2 1
0 1 5

Output:
5
Explanation:
Only one Spanning Tree is possible
which has a weight of 5.
 

Your task:
Since this is a functional problem you don't have to worry about input, you just have to complete the function spanningTree() which takes a number of vertices V and an adjacency list adj as input parameters and returns an integer denoting the sum of weights of the edges of the Minimum Spanning Tree. Here adj[i] contains vectors of size 2, where the first integer in that vector denotes the end of the edge and the second integer denotes the edge weight.

Expected Time Complexity: O(ElogV).
Expected Auxiliary Space: O(V2).
---------------------------------------------------------------------------------
class Solution {
    static int spanningTree(int V, int E, List<List<int[]>> adj) {
        // Code Here.
        int count=0;
        int dist[]= new int[V];
        Arrays.fill(dist,Integer.MAX_VALUE);
        PriorityQueue<Pair> queue=new PriorityQueue<>((x1,x2)->x1.cost-x2.cost);
        boolean[] visited=new boolean[V];
        queue.add(new Pair(0,0));
        while(!queue.isEmpty())
        {
            int node=queue.peek().node;
            int cost=queue.peek().cost;
            queue.poll();
            if(visited[node]) continue;
            visited[node]=true;
            count=count+cost;
            for(int[] temp:adj.get(node))
            {
                int currNode=temp[0];
                int currCost=temp[1];
                if( !visited[currNode])
                {
                    queue.add(new Pair(currNode,currCost));
                    
                }
            }
        }
        return count;
        
    }
}
class Pair{
    int node,cost;
    Pair(int node,int cost)
    {
        this.node=node;
        this.cost=cost; 
    }
}
--------------------------------------------------------------------------------------------------------------------------
                       -------------------------
-----------------------|Why Use a PriorityQueue? |---------------
                       -------------------------
Minimizing Edge Cost: The priority queue always extracts the node with the smallest edge cost first. This is essential for Prim's algorithm, which greedily selects the smallest edge connecting the growing MST to a new vertex.
Efficient Access: The priority queue allows efficient access to the smallest element (logarithmic time complexity), making the algorithm efficient.
Dynamic Edge Selection: As new edges are explored, they are dynamically added to the priority queue, ensuring that the smallest edge is always considered next.
In summary, the PriorityQueue is crucial for maintaining the edges to be considered and ensuring that the next smallest edge is always selected efficiently, which is the core of Prim's algorithm for finding the MST.
   ---------------   ----------------  ------------------   ------------------   ----------------   --------------   --------------   ----------------   --------------   -----------------   ----------------  --------------------
-----------------------------------------------------------------------------------------------------------------
6   ------------>
--------------------------------  
Steps by Knight
MediumAccuracy: 37.32%Submissions: 108K+Points: 4
Be the comment of the day in POTD and win a GfG T-Shirt!
Solve right now

banner
Given a square chessboard, the initial position of Knight and position of a target. Find out the minimum steps a Knight will take to reach the target position.

Note:
The initial and the target position coordinates of Knight have been given according to 1-base indexing.

 

Example 1:

Input:
N=6
knightPos[ ] = {4, 5}
targetPos[ ] = {1, 1}
Output:
3
Explanation:

Knight takes 3 step to reach from 
(4, 5) to (1, 1):
(4, 5) -> (5, 3) -> (3, 2) -> (1, 1).
 

 

Your Task:
You don't need to read input or print anything. Your task is to complete the function minStepToReachTarget() which takes the initial position of Knight (KnightPos), the target position of Knight (TargetPos), and the size of the chessboard (N) as input parameters and returns the minimum number of steps required by the knight to reach from its current position to the given target position or return -1 if its not possible.

 

Expected Time Complexity: O(N2).
Expected Auxiliary Space: O(N2).

 

Constraints:
1 <= N <= 1000
1 <= Knight_pos(X, Y), Targer_pos(X, Y) <= N
---------------------------------------------------------------------------
class Solution
{
    //Function to find out minimum steps Knight needs to reach target position.
    public int minStepToReachTarget(int KnightPos[], int TargetPos[], int N)
    {
        // Code here
        if(KnightPos[0]==TargetPos[0] && KnightPos[1]==TargetPos[1])
        return 0;
        boolean visited[][]=new boolean[N+1][N+1];
        int[] rowMoves = {-2, -1, 1, 2, 2, 1, -1, -2};
        int[] colMoves = {1, 2, 2, 1, -1, -2, -2, -1};
        Queue<Pair> queue=new LinkedList<>();
        queue.add(new Pair(KnightPos[0],KnightPos[1],0));
        visited[KnightPos[0]][KnightPos[1]]=true;
        while(!queue.isEmpty())
        {
            int row=queue.peek().row;
            int col=queue.peek().col;
            int dist=queue.peek().dist;
           
            queue.poll();
            for(int i=0;i<8;i++)
            {
                int currRow=row+rowMoves[i];
                int currCol=col+colMoves[i];
                if(currRow>=1 && currCol>=1 && currRow<=N && currCol<=N &&
                    !visited[currRow][currCol]){
                         if(currRow==TargetPos[0] && currCol==TargetPos[1])
            {
                return dist+1;
            }
                         visited[currRow][currCol]=true;
                        queue.add(new Pair(currRow,currCol,dist+1));
                    }
            }
            
        }
        return -1;
    }
}
class Pair{
    int row,col,dist;
    Pair(int row,int col,int dist)
    {
        this.row=row;
        this.col=col;
        this.dist=dist;
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------
7>
-----------------------------------
Number of Provinces
Difficulty: MediumAccuracy: 54.29%Submissions: 96K+Points: 4
Given an undirected graph with V vertices. We say two vertices u and v belong to a single province if there is a path from u to v or v to u. Your task is to find the number of provinces.

Note: A province is a group of directly or indirectly connected cities and no other cities outside of the group.

Example 1:

Input:
[
 [1, 0, 1],
 [0, 1, 0],
 [1, 0, 1]
]

Output:
2
Explanation:
The graph clearly has 2 Provinces [1,3] and [2]. As city 1 and city 3 has a path between them they belong to a single province. City 2 has no path to city 1 or city 3 hence it belongs to another province.
Example 2:
Input:
[
 [1, 1],
 [1, 1]
]

Output :
1

Your Task:  
You don't need to read input or print anything. Your task is to complete the function numProvinces() which takes an integer V and an adjacency matrix adj(as a 2d vector) as input and returns the number of provinces. adj[i][j] = 1, if nodes i and j are connected and adj[i][j] = 0, if not connected.


Expected Time Complexity: O(V2)
Expected Auxiliary Space: O(V)
------------------------------------------------------------------------
class Solution {
    static int numProvinces(ArrayList<ArrayList<Integer>> adj, int V) {
        // code here
        boolean visited[]=new boolean[V];
       
        Queue<Integer> queue=new LinkedList<>();
       int count=0;
        for(int i=0;i<V;i++){
            if(!visited[i]){
            count=count+1;
             queue.add(i);
        while(!queue.isEmpty())
        {
            int node=queue.peek();
            queue.poll();
            visited[node]=true;
            for(int j=0;j<adj.get(node).size();j++)
            {
                if(adj.get(node).get(j) == 1 && !visited[j])
                queue.add(j);
            }
        }}
        }
        return count;
    }
};
------------------------------------------------------------------------------------------------------------------------------------------
8>
---------------------------------
Minimum Multiplications to reach End
Difficulty: MediumAccuracy: 48.94%Submissions: 94K+Points: 4
Given start, end and an array arr of n numbers. At each step, start is multiplied with any number in the array and then mod operation with 100000 is done to get the new start.

Your task is to find the minimum steps in which end can be achieved starting from start. If it is not possible to reach end, then return -1.

Example 1:

Input:
arr[] = {2, 5, 7}
start = 3, end = 30
Output:
2
Explanation:
Step 1: 3*2 = 6 % 100000 = 6 
Step 2: 6*5 = 30 % 100000 = 30
Example 2:

Input:
arr[] = {3, 4, 65}
start = 7, end = 66175
Output:
4
Explanation:
Step 1: 7*3 = 21 % 100000 = 21 
Step 2: 21*3 = 63 % 100000 = 63 
Step 3: 63*65 = 4095 % 100000 = 4095 
Step 4: 4095*65 = 266175 % 100000 = 66175
Your Task:
You don't need to print or input anything. Complete the function minimumMultiplications() which takes an integer array arr, an integer start and an integer end as the input parameters and returns an integer, denoting the minumum steps to reach in which end can be achieved starting from start.

Expected Time Complexity: O(105)
Expected Space Complexity: O(105)
----------------------------------------------------
class Solution {
    int minimumMultiplications(int[] arr, int start, int end) {
        // Your code here
        Queue<Pair> queue=new LinkedList<>();
        boolean[] visited=new boolean[100000];
        visited[start]=true;
        queue.add(new Pair(start,0));
        while(!queue.isEmpty())
        {
            
            
            int size=queue.size();
            for(int i=0;i<size;i++)
            {
                int num=queue.peek().num;
               
                int count=queue.peek().count;
                if(num==end) return count;
                queue.poll();
                for(int j=0;j<arr.length;j++)
                {
                    if((num*arr[j])%100000==end) return count+1;
                    if(!visited[(num*arr[j])%100000]){
                        
                     visited[(num*arr[j])%100000]=true;
                    queue.add(new Pair((num*arr[j])%100000,count+1));}
                }
            }
        }
        return -1;
    }
}

class Pair{
    int num;
    int count;
    Pair(int num,int count)
    {
        this.num=num;
        this.count=count;
    }
}
-------------------------------------------------------------------------------------------------------------------------------
9>
-----------------------------------
Find whether path exist
Difficulty: MediumAccuracy: 45.09%Submissions: 83K+Points: 4
Given a grid of size n*n filled with 0, 1, 2, 3. Check whether there is a path possible from the source to destination. You can traverse up, down, right and left.
The description of cells is as follows:

A value of cell 1 means Source.
A value of cell 2 means Destination.
A value of cell 3 means Blank cell.
A value of cell 0 means Wall.
Note: There are only a single source and a single destination.
 

Example 1:

Input: grid = {{3,0,3,0,0},{3,0,0,0,3}
,{3,3,3,3,3},{0,2,3,0,0},{3,0,0,1,3}}
Output: 0
Explanation: The grid is-
3 0 3 0 0 
3 0 0 0 3 
3 3 3 3 3 
0 2 3 0 0 
3 0 0 1 3 
There is no path to reach at (3,1) i,e at 
destination from (4,3) i,e source.
Example 2:

Input: grid = {{1,3},{3,2}}
Output: 1
Explanation: The grid is-
1 3
3 2
There is a path from (0,0) i,e source to (1,1) 
i,e destination.
 

Your Task:
You don't need to read or print anything. Your task is to complete the function is_Possible() which takes the grid as input parameter and returns boolean value 1 if there is a path otherwise returns 0.
 

Expected Time Complexity: O(n2)
Expected Auxiliary Space: O(n2)
-----------------------------------------------------------------------
class Solution
{
    //Function to find whether a path exists from the source to destination.
    public boolean is_Possible(int[][] grid)
    {
        // Code here
        boolean visited[][]=new boolean[grid.length][grid[0].length];
        int source[]=new int[2];
        int dest[]=new int[2];
        for(int i=0;i<grid.length;i++)
        {
            for(int j=0;j<grid[0].length;j++)
            {
                if(grid[i][j]==1)
                {
                    source[0]=i;
                    source[1]=j;
                }
                if(grid[i][j]==2)
                {
                    dest[0]=i;
                    dest[1]=j;
                }
            }
        }
        // System.out.println(dest[0]+"--"+dest[1]);
        int delRow[]={-1,0,0,1};
        int delCol[]={0,-1,1,0};
        Queue<Pair> queue=new LinkedList<>();
        queue.add(new Pair(source[0],source[1]));
        visited[source[0]][source[1]]=true;
        while(!queue.isEmpty())
        {
            int row=queue.peek().row;
            int col=queue.peek().col;
            if(grid[row][col]==2) return true;
            queue.poll();
            for(int i=0;i<4;i++)
            {
                int nRow=row+delRow[i];
                int nCol=col+delCol[i];
                if(nRow>=0 && nRow<grid.length && nCol>=0 && nCol<grid[0].length && grid[nRow][nCol]!=0 && !visited[nRow][nCol])
                {
                    visited[nRow][nCol]=true;
                    // System.out.println("yes");
                    queue.add(new Pair(nRow,nCol));
                    // System.out.println(nRow+"->"+nCol);
                }
            }
        }
        return false;
        
    }
}
class Pair{
    int row,col;
    Pair(int row,int col)
    {
        this.row=row;
        this.col=col;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------
10
-----------------------------------
Course Schedule
Difficulty: MediumAccuracy: 51.77%Submissions: 67K+Points: 4
There are a total of n tasks you have to pick, labelled from 0 to n-1. Some tasks may have prerequisite tasks, for example to pick task 0 you have to first finish tasks 1, which is expressed as a pair: [0, 1]
Given the total number of n tasks and a list of prerequisite pairs of size m. Find a ordering of tasks you should pick to finish all tasks.
Note: There may be multiple correct orders, you just need to return any one of them. If it is impossible to finish all tasks, return an empty array. Driver code will print "No Ordering Possible", on returning an empty array. Returning any correct order will give the output as 1, whereas any invalid order will give the output 0. 

Example 1:

Input:
n = 2, m = 1
prerequisites = {{1, 0}}
Output:
1
Explanation:
The output 1 denotes that the order is valid. So, if you have, implemented your function correctly, then output would be 1 for all test cases. One possible order is [0, 1].
Example 2:

Input:
n = 4, m = 4
prerequisites = {{1, 0},
               {2, 0},
               {3, 1},
               {3, 2}}
Output:
1
Explanation:
There are a total of 4 tasks to pick. To pick task 3 you should have finished both tasks 1 and 2. Both tasks 1 and 2 should be pick after you finished task 0. So one correct task order is [0, 1, 2, 3]. Another correct ordering is [0, 2, 1, 3]. Returning any of these order will result in an output of 1.
Your Task:
The task is to complete the function findOrder() which takes two integers n, and m and a list of lists of size m*2 denoting the prerequisite pairs as input and returns any correct order to finish all the tasks. Return an empty array if it's impossible to finish all tasks.

Expected Time Complexity: O(n+m).
Expected Auxiliary Space: O(n+m).
------------------------------------------------------------------------
class Solution
{
    static int[] findOrder(int n, int m, ArrayList<ArrayList<Integer>> prerequisites) 
    {
        // add your code here
        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();
        int[] order=new int[n];
        boolean[] visited=new boolean[n];
        Stack<Integer> stack=new Stack<>();
        boolean[] onStack=new boolean[n];
        for(int i=0;i<n;i++)
        adj.add(new ArrayList<>());
        for(ArrayList<Integer> node:prerequisites)
        {
            adj.get(node.get(1)).add(node.get(0));
        }
        for(int i=0;i<n;i++)
        {
            if(!visited[i])
            {
                if(!dfs(i,adj,visited,stack,onStack))
                return new int[0];
            }
        }
        int index=0;
        while(!stack.isEmpty())
        {
            order[index++]=stack.pop();
        }
        return order;
        
    }
    static boolean dfs(int node,ArrayList<ArrayList<Integer>> adj, boolean[] visited,Stack<Integer> stack,boolean[] onStack)
    {
        visited[node]=true;
        onStack[node]=true;
        for(int currNode:adj.get(node))
        {
            if(!visited[currNode]){
            if(!dfs(currNode,adj,visited,stack,onStack))
            return false;
            }else if(onStack[currNode])
            {
                return false;
            }
        }
        onStack[node]=false;
        stack.push(node);
        return true;
        
    }
}
-------------------------------------------------------------------------------------------------------------------------------------------


