This file contains the Important Question on DSA
---------------------------------------------------------------------------------------------------------
1->Shortest Distance in a Binary Maze
------------------------------------------
MediumAccuracy: 58.22%Submissions: 57K+Points: 4
Be the comment of the day in POTD and win a GfG T-Shirt!
Solve right now

banner
Given a n * m matrix grid where each element can either be 0 or 1. You need to find the shortest distance between a given source cell to a destination cell. The path can only be created out of a cell if its value is 1. If the path is not possible between source cell and destination cell, then return -1.
Note : You can move into an adjacent cell if that adjacent cell is filled with element 1. Two cells are adjacent if they share a side. In other words, you can move in one of the four directions, Up, Down, Left and Right. The source and destination cell are based on the zero based indexing. The destination cell should be 1.

Example 1:

Input:
grid[][] = {{1, 1, 1, 1},
            {1, 1, 0, 1},
            {1, 1, 1, 1},
            {1, 1, 0, 0},
            {1, 0, 0, 1}}
source = {0, 1}
destination = {2, 2}
Output:
3
Explanation:
1 1 1 1
1 1 0 1
1 1 1 1
1 1 0 0
1 0 0 1
The highlighted part in the matrix denotes the 
shortest path from source to destination cell.
Example 2:

Input:
grid[][] = {{1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1},
            {1, 1, 1, 1, 0},
            {1, 0, 1, 0, 1}}
source = {0, 0}
destination = {3, 4}
Output:
-1
Explanation:
The path is not possible between source and 
destination, hence return -1.
Your Task:

You don't need to read or print anything. Your task is to complete the function shortestPath() which takes the a 2D integer array grid, source cell and destination cell as an input parameters and returns the shortest distance between source and destination cell.

Expected Time Complexity: O(n * m)
Expected Space Complexity: O(n * m)

Constraints:

1 ≤ n, m ≤ 500
grid[i][j] == 0 or grid[i][j] == 1
The source and destination cells are always inside the given matrix.
-----------
Solution
----------------------------------------------------------------------------------------
class Solution {

    int shortestPath(int[][] grid, int[] source, int[] destination) {

        // Your code here
        int[] delRow={-1,0,0,1};
        int[] delCol={0,-1,1,0};
        int[][] dist=new int[grid.length][grid[0].length];
        Queue<Pair> queue=new LinkedList<>();
        for(int i=0;i<grid.length;i++)
        {
            Arrays.fill(dist[i],Integer.MAX_VALUE);
        }
        dist[source[0]][source[1]]=0;
        queue.add(new Pair(source[0],source[1],0));
        while(!queue.isEmpty())
        {
            int row=queue.peek().row;
            int col=queue.peek().col;
            int count=queue.peek().count;
            if(row==destination[0] && col==destination[1])
            return count;
            queue.poll();
            for(int i=0;i<4;i++)
            {
                int currRow=row+delRow[i];
                int currCol=col+delCol[i];
                int currCount=count+1;
                if(currRow>=0 && currRow<grid.length && currCol>=0 &&
                    currCol<grid[0].length && grid[currRow][currCol]!=0
                    && dist[currRow][currCol]==Integer.MAX_VALUE
                ){
                    dist[currRow][currCol]=currCount;
                    queue.add(new Pair(currRow,currCol,currCount));
                }
            }
        }
        return -1;
    }
}

class Pair{
    int row,col,count;
    Pair(int row,int col,int count)
    {
        this.row=row;
        this.col=col;
        this.count=count;
    }
}
--------------------------------------------------------------------------------------------------
2>
Shortest Source to Destination Path
MediumAccuracy: 24.69%Submissions: 110K+Points: 4
Be the comment of the day in POTD and win a GfG T-Shirt!
Solve right now

banner
Given a 2D binary matrix A(0-based index) of dimensions NxM. Find the minimum number of steps required to reach from (0,0) to (X, Y).
Note: You can only move left, right, up and down, and only through cells that contain 1.

Example 1:

Input:
N=3, M=4
A=[[1,0,0,0], 
   [1,1,0,1],
   [0,1,1,1]]
X=2, Y=3 
Output:
5
Explanation:
The shortest path is as follows:
(0,0)->(1,0)->(1,1)->(2,1)->(2,2)->(2,3).
Example 2:

Input:
N=3, M=4
A=[[1,1,1,1],
   [0,0,0,1],
   [0,0,0,1]]
X=0, Y=3
Output:
3
Explanation:
The shortest path is as follows:
(0,0)->(0,1)->(0,2)->(0,3).
Your Task:
You don't need to read input or print anything. Your task is to complete the function shortestDistance() which takes the integer N, M, X, Y, and the 2D binary matrix A as input parameters and returns the minimum number of steps required to go from (0,0) to (X, Y).If it is impossible to go from (0,0) to (X, Y),then function returns -1. If value of the cell (0,0) is 0 (i.e  A[0][0]=0) then return -1.

Expected Time Complexity:O(N*M)
Expected Auxillary Space:O(N*M)

Constraints:
1 <= N,M <= 250
0 <= X < N
0 <= Y < M
0 <= A[i][j] <= 1
--------------------------------------------------------
Solution------------------------
class Solution {
    int shortestDistance(int N, int M, int A[][], int X, int Y) {
        // code here
        if(A[0][0]==0) return -1;
        int delRow[]={-1,0,0,1};
        int delCol[]={0,-1,1,0};
        int[][] arr=new int[A.length][A[0].length];
        for(int i=0;i<A.length;i++)
        {
            Arrays.fill(arr[i],-1);
        }
        Queue<Pair> queue=new LinkedList<>();
        queue.add(new Pair(0,0,0));
        while(!queue.isEmpty())
        {
            int row=queue.peek().row;
            int col=queue.peek().col;
            int count=queue.peek().count;
            if(row==X && col==Y){
                // System.out.println(X+" "+Y +" "+row+" "+col+"");
            return count;
            }
            queue.poll();
            for(int i=0;i<4;i++)
            {
                int currRow=row+delRow[i];
                int currCol=col+delCol[i];
                if(currRow>=0 && currRow<A.length && currCol>=0 && currCol<A[0].length
                    && A[currRow][currCol]!=0 && arr[currRow][currCol]==-1
                )
                {
                    arr[currRow][currCol]=1;
                    queue.add(new Pair(currRow,currCol,count+1));
                }
            }
        }
        return -1;
    }
};

class Pair{
    int row,col,count;
    Pair(int row,int col,int count)
    {
        this.row=row;
        this.col=col;
        this.count=count;
    }
}
---------------------------------------------------------------------------------------------------------------
3>
Shortest Path in Weighted undirected graph
MediumAccuracy: 50.0%Submissions: 39K+Points: 4
Be the comment of the day in POTD and win a GfG T-Shirt!
Solve right now

banner
You are given a weighted undirected graph having n vertices numbered from 1 to n and m edges describing there are edges between a to b with some weight, find the shortest path between the vertex 1 and the vertex n and if path does not exist then return a list consisting of only -1.

Note - 
1. If there exists a path, then return a list whose first element is the weight of the path.
2. If no path exists then return a list containing a single element -1.

Example:
Input:
n = 5, m= 6
edges = [[1,2,2], [2,5,5], [2,3,4], [1,4,1],[4,3,3],[3,5,1]]
Output:
5 1 4 3 5
Explaination:
Shortest path from 1 to n is by the path 1 4 3 5 whose weight is 5. 

Your Task:
You don't need to read input or print anything. Your task is to complete the function shortestPath() which takes n vertex and m edges and vector of edges having weight as inputs and returns the shortest path between vertex 1 to n.

Expected Time Complexity: O(m* log(n))
Expected Space Complexity: O(n)

Constraint:
2 <= n <= 105
0 <= m <= 105
0<= a, b <= n
1 <= w <= 105
------------------------------------------------
class Solution{
    public List<Integer> shortestPath(int n, int m, int edges[][]){
        //  Code Here.
        ArrayList<ArrayList<Pair>> adj=new  ArrayList<>();
        for(int i=0;i<n+1;i++)
        adj.add(new ArrayList<>());
        for (int i = 0; i < m; i++) {
            adj.get(edges[i][0]).add(new Pair(edges[i][1], edges[i][2]));
            adj.get(edges[i][1]).add(new Pair(edges[i][0], edges[i][2])); // Assuming undirected graph
        }
        int[] parent=new int[n+1];
        int dist[]=new int[n+1];
        Arrays.fill(dist,Integer.MAX_VALUE);
        for(int i=0;i<n+1;i++)
        parent[i]=i;
        dist[1]=0;
        ArrayList<Integer> path=new ArrayList<>();
        PriorityQueue<Pair> queue=new PriorityQueue<>((x1,x2)->x1.weight-x2.weight);
        queue.add(new Pair(1,0));
        while(!queue.isEmpty())
        {
            int node=queue.peek().node;
            int weight=queue.peek().weight;
            queue.poll();
            for(Pair pair:adj.get(node))
            {
                int currNode=pair.node;
                int currWeight=pair.weight;
                if(dist[currNode]>weight+currWeight)
                {
                    dist[currNode]=weight+currWeight;
                    queue.add(new Pair(currNode,dist[currNode]));
                    parent[currNode]=node;
                }
            }
        }
        // for(int i=0;i<n+1;i++)
        // {
        //     System.out.print(dist[i]+" -"+n);
        // }
        if(dist[n]==Integer.MAX_VALUE)
        {
            // System.out.println("NO");
            path.add(-1);
            return path;
        }
        int node=n;
        while(parent[node]!=node)
        {
            path.add(node);
            node=parent[node];
        }
        
        path.add(1);
        Collections.reverse(path);
        // System.out.println(dist[n-1]);
        path.add(0,dist[n]);
    // System.out.println(path);
        // path.add(parent[n]);
        return path;
        
    }
}
class Pair{
    int node,weight;
    Pair(int node,int weight)
    {
        this.node=node;
        this.weight=weight;
    }
}
------------------------------------------------------------------------------------------------------------------------------